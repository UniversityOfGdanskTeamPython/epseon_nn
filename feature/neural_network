import torch
from torch import nn
from typing import List
import numpy as np
from pathlib import Path
import torch.optim as optim

THIS_DIR = Path(__file__).parent

def load_serialized_data_from_file(path: str) -> List[float]:
	input_y: List[float] = []
	with open(path, "r") as file_in:
		for line in file_in.readlines():
			_x, y = line.strip().split()
			input_y.append(float(y))
	return input_y

directories_list = list((THIS_DIR/"data").glob(pattern="wave.dat*"))

data_0 = [load_serialized_data_from_file(x.as_posix()) for x in directories_list]
tensor_0 = torch.Tensor(data_0)

"""The code below is not ready yet."""
#class SplainNN(nn.Module):
#    def __init__(self):
#        super(SplainNN, self).__init__()
#        # Assuming we want two linear layers with a ReLU activation in between
#        self.layer1 = nn.Linear(40*165, 500)  # First linear layer
#        self.relu = nn.ReLU()                 # ReLU activation
#        self.layer2 = nn.Linear(500, 165)     # Second linear layer
#
#    def forward(self, x):
#        x = x.view(-1, 40*165)  # Flatten the input
#        x = self.relu(self.layer1(x))
#        x = self.layer2(x)
#        return x
#
## Create an instance of the neural network
#model = SplainNN()
#
## Example input tensor (40x165)
#input_tensor = tensor_0
#
## Forward pass through the network
#output = model(input_tensor)
#
#output.shape, output
#
## Assuming `train_loader` is a PyTorch DataLoader containing your training data
## and `valid_loader` is your validation data loader
#
## Loss function
#criterion = nn.MSELoss()
#
## Optimizer (Adam is used here, but you can choose others like SGD)
#optimizer = optim.Adam(model.parameters(), lr=0.001)
#
## Number of epochs (full passes through the dataset)
#num_epochs = 10
#
#for epoch in range(num_epochs):
#    model.train()  # Set the model to training mode
#    for inputs, targets in train_loader:
#        # Forward pass: Compute predicted y by passing x to the model
#        outputs = model(inputs)
#
#        # Compute and print loss
#        loss = criterion(outputs, targets)
#
#        # Zero gradients, perform a backward pass, and update the weights.
#        optimizer.zero_grad()
#        loss.backward()
#        optimizer.step()
#
#    # Validation step
#    model.eval()  # Set the model to evaluation mode
#    with torch.no_grad():
#        valid_loss = 0
#        for inputs, targets in valid_loader:
#            outputs = model(inputs)
#            valid_loss += criterion(outputs, targets).item()
#        
#        valid_loss /= len(valid_loader)
#        print(f"Epoch {epoch}: Train Loss: {loss.item():.4f}, Valid Loss: {valid_loss:.4f}")